// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.8.1
//   protoc               v6.32.1
// source: order.proto
/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { makeGenericClientConstructor } from "@grpc/grpc-js";
import { Timestamp } from "./google/protobuf/timestamp.js";
export const protobufPackage = "orders";
function createBaseOrderItem() {
  return {
    id: 0,
    order_id: 0,
    product_id: 0,
    quantity: 0,
    price: 0,
    title: "",
    image: "",
  };
}
export const OrderItem = {
  encode(message, writer = new BinaryWriter()) {
    if (message.id !== 0) {
      writer.uint32(8).int32(message.id);
    }
    if (message.order_id !== 0) {
      writer.uint32(16).int32(message.order_id);
    }
    if (message.product_id !== 0) {
      writer.uint32(24).int32(message.product_id);
    }
    if (message.quantity !== 0) {
      writer.uint32(32).int32(message.quantity);
    }
    if (message.price !== 0) {
      writer.uint32(41).double(message.price);
    }
    if (message.title !== "") {
      writer.uint32(50).string(message.title);
    }
    if (message.image !== "") {
      writer.uint32(58).string(message.image);
    }
    return writer;
  },
  decode(input, length) {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrderItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }
          message.id = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }
          message.order_id = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }
          message.product_id = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }
          message.quantity = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 41) {
            break;
          }
          message.price = reader.double();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }
          message.title = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }
          message.image = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      order_id: isSet(object.order_id) ? globalThis.Number(object.order_id) : 0,
      product_id: isSet(object.product_id)
        ? globalThis.Number(object.product_id)
        : 0,
      quantity: isSet(object.quantity) ? globalThis.Number(object.quantity) : 0,
      price: isSet(object.price) ? globalThis.Number(object.price) : 0,
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      image: isSet(object.image) ? globalThis.String(object.image) : "",
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.order_id !== 0) {
      obj.order_id = Math.round(message.order_id);
    }
    if (message.product_id !== 0) {
      obj.product_id = Math.round(message.product_id);
    }
    if (message.quantity !== 0) {
      obj.quantity = Math.round(message.quantity);
    }
    if (message.price !== 0) {
      obj.price = message.price;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.image !== "") {
      obj.image = message.image;
    }
    return obj;
  },
  create(base) {
    return OrderItem.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseOrderItem();
    message.id = object.id ?? 0;
    message.order_id = object.order_id ?? 0;
    message.product_id = object.product_id ?? 0;
    message.quantity = object.quantity ?? 0;
    message.price = object.price ?? 0;
    message.title = object.title ?? "";
    message.image = object.image ?? "";
    return message;
  },
};
function createBaseOrder() {
  return {
    id: 0,
    user_id: 0,
    total: 0,
    status: "",
    order_items: [],
    payment_id: 0,
    shipping_address: "",
  };
}
export const Order = {
  encode(message, writer = new BinaryWriter()) {
    if (message.id !== 0) {
      writer.uint32(8).int32(message.id);
    }
    if (message.user_id !== 0) {
      writer.uint32(16).int32(message.user_id);
    }
    if (message.total !== 0) {
      writer.uint32(25).double(message.total);
    }
    if (message.status !== "") {
      writer.uint32(34).string(message.status);
    }
    if (message.created_at !== undefined) {
      Timestamp.encode(
        toTimestamp(message.created_at),
        writer.uint32(42).fork()
      ).join();
    }
    for (const v of message.order_items) {
      OrderItem.encode(v, writer.uint32(50).fork()).join();
    }
    if (message.payment_id !== 0) {
      writer.uint32(56).int32(message.payment_id);
    }
    if (message.shipping_address !== "") {
      writer.uint32(66).string(message.shipping_address);
    }
    return writer;
  },
  decode(input, length) {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrder();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }
          message.id = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }
          message.user_id = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }
          message.total = reader.double();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.status = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }
          message.created_at = fromTimestamp(
            Timestamp.decode(reader, reader.uint32())
          );
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }
          message.order_items.push(OrderItem.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }
          message.payment_id = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }
          message.shipping_address = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      user_id: isSet(object.user_id) ? globalThis.Number(object.user_id) : 0,
      total: isSet(object.total) ? globalThis.Number(object.total) : 0,
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      created_at: isSet(object.created_at)
        ? fromJsonTimestamp(object.created_at)
        : undefined,
      order_items: globalThis.Array.isArray(object?.order_items)
        ? object.order_items.map((e) => OrderItem.fromJSON(e))
        : [],
      payment_id: isSet(object.payment_id)
        ? globalThis.Number(object.payment_id)
        : 0,
      shipping_address: isSet(object.shipping_address)
        ? globalThis.String(object.shipping_address)
        : "",
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.user_id !== 0) {
      obj.user_id = Math.round(message.user_id);
    }
    if (message.total !== 0) {
      obj.total = message.total;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.created_at !== undefined) {
      obj.created_at = message.created_at.toISOString();
    }
    if (message.order_items?.length) {
      obj.order_items = message.order_items.map((e) => OrderItem.toJSON(e));
    }
    if (message.payment_id !== 0) {
      obj.payment_id = Math.round(message.payment_id);
    }
    if (message.shipping_address !== "") {
      obj.shipping_address = message.shipping_address;
    }
    return obj;
  },
  create(base) {
    return Order.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseOrder();
    message.id = object.id ?? 0;
    message.user_id = object.user_id ?? 0;
    message.total = object.total ?? 0;
    message.status = object.status ?? "";
    message.created_at = object.created_at ?? undefined;
    message.order_items =
      object.order_items?.map((e) => OrderItem.fromPartial(e)) || [];
    message.payment_id = object.payment_id ?? 0;
    message.shipping_address = object.shipping_address ?? "";
    return message;
  },
};
function createBaseCreateOrderRequest() {
  return {
    user_id: 0,
    items: [],
    total: 0,
    payment_id: 0,
    shipping_address: "",
  };
}
export const CreateOrderRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.user_id !== 0) {
      writer.uint32(8).int32(message.user_id);
    }
    for (const v of message.items) {
      OrderItem.encode(v, writer.uint32(18).fork()).join();
    }
    if (message.total !== 0) {
      writer.uint32(25).double(message.total);
    }
    if (message.payment_id !== 0) {
      writer.uint32(32).int32(message.payment_id);
    }
    if (message.shipping_address !== "") {
      writer.uint32(42).string(message.shipping_address);
    }
    return writer;
  },
  decode(input, length) {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateOrderRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }
          message.user_id = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.items.push(OrderItem.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }
          message.total = reader.double();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }
          message.payment_id = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }
          message.shipping_address = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      user_id: isSet(object.user_id) ? globalThis.Number(object.user_id) : 0,
      items: globalThis.Array.isArray(object?.items)
        ? object.items.map((e) => OrderItem.fromJSON(e))
        : [],
      total: isSet(object.total) ? globalThis.Number(object.total) : 0,
      payment_id: isSet(object.payment_id)
        ? globalThis.Number(object.payment_id)
        : 0,
      shipping_address: isSet(object.shipping_address)
        ? globalThis.String(object.shipping_address)
        : "",
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.user_id !== 0) {
      obj.user_id = Math.round(message.user_id);
    }
    if (message.items?.length) {
      obj.items = message.items.map((e) => OrderItem.toJSON(e));
    }
    if (message.total !== 0) {
      obj.total = message.total;
    }
    if (message.payment_id !== 0) {
      obj.payment_id = Math.round(message.payment_id);
    }
    if (message.shipping_address !== "") {
      obj.shipping_address = message.shipping_address;
    }
    return obj;
  },
  create(base) {
    return CreateOrderRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseCreateOrderRequest();
    message.user_id = object.user_id ?? 0;
    message.items = object.items?.map((e) => OrderItem.fromPartial(e)) || [];
    message.total = object.total ?? 0;
    message.payment_id = object.payment_id ?? 0;
    message.shipping_address = object.shipping_address ?? "";
    return message;
  },
};
function createBaseCreateOrderResponse() {
  return { success: false, message: "" };
}
export const CreateOrderResponse = {
  encode(message, writer = new BinaryWriter()) {
    if (message.order !== undefined) {
      Order.encode(message.order, writer.uint32(10).fork()).join();
    }
    if (message.success !== false) {
      writer.uint32(16).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(26).string(message.message);
    }
    return writer;
  },
  decode(input, length) {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateOrderResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.order = Order.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }
          message.success = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      order: isSet(object.order) ? Order.fromJSON(object.order) : undefined,
      success: isSet(object.success)
        ? globalThis.Boolean(object.success)
        : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.order !== undefined) {
      obj.order = Order.toJSON(message.order);
    }
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },
  create(base) {
    return CreateOrderResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseCreateOrderResponse();
    message.order =
      object.order !== undefined && object.order !== null
        ? Order.fromPartial(object.order)
        : undefined;
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    return message;
  },
};
function createBaseGetOrderRequest() {
  return { id: 0 };
}
export const GetOrderRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.id !== 0) {
      writer.uint32(8).int32(message.id);
    }
    return writer;
  },
  decode(input, length) {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetOrderRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }
          message.id = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return { id: isSet(object.id) ? globalThis.Number(object.id) : 0 };
  },
  toJSON(message) {
    const obj = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    return obj;
  },
  create(base) {
    return GetOrderRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGetOrderRequest();
    message.id = object.id ?? 0;
    return message;
  },
};
function createBaseGetOrderResponse() {
  return {};
}
export const GetOrderResponse = {
  encode(message, writer = new BinaryWriter()) {
    if (message.order !== undefined) {
      Order.encode(message.order, writer.uint32(10).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetOrderResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.order = Order.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      order: isSet(object.order) ? Order.fromJSON(object.order) : undefined,
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.order !== undefined) {
      obj.order = Order.toJSON(message.order);
    }
    return obj;
  },
  create(base) {
    return GetOrderResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseGetOrderResponse();
    message.order =
      object.order !== undefined && object.order !== null
        ? Order.fromPartial(object.order)
        : undefined;
    return message;
  },
};
function createBaseListOrdersByUserRequest() {
  return { user_id: 0 };
}
export const ListOrdersByUserRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.user_id !== 0) {
      writer.uint32(8).int32(message.user_id);
    }
    return writer;
  },
  decode(input, length) {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListOrdersByUserRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }
          message.user_id = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      user_id: isSet(object.user_id) ? globalThis.Number(object.user_id) : 0,
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.user_id !== 0) {
      obj.user_id = Math.round(message.user_id);
    }
    return obj;
  },
  create(base) {
    return ListOrdersByUserRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseListOrdersByUserRequest();
    message.user_id = object.user_id ?? 0;
    return message;
  },
};
function createBaseListOrdersByUserResponse() {
  return { orders: [] };
}
export const ListOrdersByUserResponse = {
  encode(message, writer = new BinaryWriter()) {
    for (const v of message.orders) {
      Order.encode(v, writer.uint32(10).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListOrdersByUserResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.orders.push(Order.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      orders: globalThis.Array.isArray(object?.orders)
        ? object.orders.map((e) => Order.fromJSON(e))
        : [],
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.orders?.length) {
      obj.orders = message.orders.map((e) => Order.toJSON(e));
    }
    return obj;
  },
  create(base) {
    return ListOrdersByUserResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseListOrdersByUserResponse();
    message.orders = object.orders?.map((e) => Order.fromPartial(e)) || [];
    return message;
  },
};
function createBaseUpdateOrderStatusRequest() {
  return { id: 0, status: "" };
}
export const UpdateOrderStatusRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.id !== 0) {
      writer.uint32(8).int32(message.id);
    }
    if (message.status !== "") {
      writer.uint32(18).string(message.status);
    }
    return writer;
  },
  decode(input, length) {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateOrderStatusRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }
          message.id = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.status = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      status: isSet(object.status) ? globalThis.String(object.status) : "",
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    return obj;
  },
  create(base) {
    return UpdateOrderStatusRequest.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseUpdateOrderStatusRequest();
    message.id = object.id ?? 0;
    message.status = object.status ?? "";
    return message;
  },
};
function createBaseUpdateOrderStatusResponse() {
  return { success: false, message: "" };
}
export const UpdateOrderStatusResponse = {
  encode(message, writer = new BinaryWriter()) {
    if (message.order !== undefined) {
      Order.encode(message.order, writer.uint32(10).fork()).join();
    }
    if (message.success !== false) {
      writer.uint32(16).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(26).string(message.message);
    }
    return writer;
  },
  decode(input, length) {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateOrderStatusResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.order = Order.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }
          message.success = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  fromJSON(object) {
    return {
      order: isSet(object.order) ? Order.fromJSON(object.order) : undefined,
      success: isSet(object.success)
        ? globalThis.Boolean(object.success)
        : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },
  toJSON(message) {
    const obj = {};
    if (message.order !== undefined) {
      obj.order = Order.toJSON(message.order);
    }
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },
  create(base) {
    return UpdateOrderStatusResponse.fromPartial(base ?? {});
  },
  fromPartial(object) {
    const message = createBaseUpdateOrderStatusResponse();
    message.order =
      object.order !== undefined && object.order !== null
        ? Order.fromPartial(object.order)
        : undefined;
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    return message;
  },
};
export const OrderServiceService = {
  createOrder: {
    path: "/orders.OrderService/CreateOrder",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value) =>
      Buffer.from(CreateOrderRequest.encode(value).finish()),
    requestDeserialize: (value) => CreateOrderRequest.decode(value),
    responseSerialize: (value) =>
      Buffer.from(CreateOrderResponse.encode(value).finish()),
    responseDeserialize: (value) => CreateOrderResponse.decode(value),
  },
  getOrder: {
    path: "/orders.OrderService/GetOrder",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value) =>
      Buffer.from(GetOrderRequest.encode(value).finish()),
    requestDeserialize: (value) => GetOrderRequest.decode(value),
    responseSerialize: (value) =>
      Buffer.from(GetOrderResponse.encode(value).finish()),
    responseDeserialize: (value) => GetOrderResponse.decode(value),
  },
  listOrdersByUser: {
    path: "/orders.OrderService/ListOrdersByUser",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value) =>
      Buffer.from(ListOrdersByUserRequest.encode(value).finish()),
    requestDeserialize: (value) => ListOrdersByUserRequest.decode(value),
    responseSerialize: (value) =>
      Buffer.from(ListOrdersByUserResponse.encode(value).finish()),
    responseDeserialize: (value) => ListOrdersByUserResponse.decode(value),
  },
  updateOrderStatus: {
    path: "/orders.OrderService/UpdateOrderStatus",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value) =>
      Buffer.from(UpdateOrderStatusRequest.encode(value).finish()),
    requestDeserialize: (value) => UpdateOrderStatusRequest.decode(value),
    responseSerialize: (value) =>
      Buffer.from(UpdateOrderStatusResponse.encode(value).finish()),
    responseDeserialize: (value) => UpdateOrderStatusResponse.decode(value),
  },
};
export const OrderServiceClient = makeGenericClientConstructor(
  OrderServiceService,
  "orders.OrderService"
);
function toTimestamp(date) {
  const seconds = Math.trunc(date.getTime() / 1000);
  const nanos = (date.getTime() % 1000) * 1000000;
  return { seconds, nanos };
}
function fromTimestamp(t) {
  let millis = (t.seconds || 0) * 1000;
  millis += (t.nanos || 0) / 1000000;
  return new globalThis.Date(millis);
}
function fromJsonTimestamp(o) {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}
function isSet(value) {
  return value !== null && value !== undefined;
}
//# sourceMappingURL=order.js.map
